Папка `dist` содержит скомпилированный проект. `dist/index.js` -- стартовый файл.

Исходный код находится в папке `src`. `src/index.ts` -- стартовый файл, в котором находится функция `solution(input:
Input): Output`, находящая решение к поставленной задаче. Для запуска следует выполнить команды:

```bash
yarn install # установить все компоненты
yarn start # запустить index|main
yarn test # запустить Jasmine тесты
```

Алгоритм
---

Очевидным наивным алгоритмом является полный перебор методом грубой силы: поочерёдно сдвигаем расписание каждого
устройства на 1 час, начиная со времени допустимого начала и до времени окончания (согласно режиму работы). Совокупность
сдвигов начала работы каждого устройства образует конфигурацию. Для очередной конфигурации необходимо проверить
"валидность": убедиться в том, что в каждый час общая мощность не превосходит допустимой максимальной мощности. В худшем
случае сложность работы будет `O(24^N)`, где `N` -- кол-во устройств.

В [статье](https://people.kth.se/~hsan/publications_files/CDC2011D.pdf) задача поиска оптимального расписания сведена к
решению задачи MILP (mixed-integer linear programming). На JavaScript мне неизвестен решатель, в котором возможно
запрограммировать задачу.

Возможно есть решение методом динамического программирования. Мне неизвестно, т.к. непонятно как текущую конфигурацию
представить как функцию для оптимизации от предыдущих конфигураций.

Предложенный следующий способ улучшает асимптотическое время. Худший случай -- также `O(24^N)`. Нужно найти такой способ
перебора, при котором конфигурации будут возвращаться в порядке неубывания общей стоимость. Тогда первая "валидная"
конфигурация будет ответом.

Первым подходом может показаться правильным следующий. Для каждого устройства заведём массив пар: сдвиг начала работы и
соответствующая потребляемая мощность. Отсортируем каждый массив по неубыванию значений потребляемой мощности. Заведём
`N` курсоров, инициализировав началом каждого отсортированного массива. Значения курсоров определяют текущую
конфигурацию. Следующую конфигурацию будем выбирать так: из `N` курсоров выберем такой `n`, указывающий на элемент `i`,
что следующий за ним элемент `i+1` в массиве является минимальным из всех следующих элементов остальных курсоров. Увы,
такая последовательность конфигураций будет минимальна по потребляемой мощности, но не будет перебирать всех вариантов:
после выбранного курсора для продвижения нужно перебрать все комбинации остальных курсоров, которые были до текущей
конфигурации.

Следующий логический шаг: сбросить в 0 все курсоры, кроме выбранного `n`, и перебрать их в том же порядке, что были для
текущей конфигурации, но в каждой конфигурации из истории на значение курсора `n` всегда будет `i+1`. Увы, и этот подход
не заработает: найдя очередной "минимальный" курсор, предыдущий "минимальный" также зафиксирован, и проблема в том, что
вполне может найтись конфигурация с одним "минимальным" курсором по стоимости ниже, чем конфигурация с найденными двумя.

Это подводит к окончательному методу: нужно заранее просчитать всевозможные значения суммарных показателей мощности --
их не более, чем `M^N`, где `M` -- количество тарифов в сутках. Далее отсортировать массив по суммарному потреблению.
Каждому значению массива будет соответствовать множество конфигураций `K`, где каждому устройству будет соответствовать
множество сдвигов, но при этом стоимость потребления будет оставаться неизменной. Далее нужно перебирать все
конфигурации `K` до тех пор, пока не найдётся "валидная" конфигурация. Эта конфигурация будет ответом (понятно, что в
общем случае одним из нескольких возможных). В худшем случае нужно будет перебрать все конфигурации, и сложность будет
`O(24^N)`. С другой стороны, интуитивно понятно, что 24 варианта конфигурации для устройства возможно только для
устройства с `duration=1` и сеткой тарифово на каждый час, поэтому чем больше таких устройств, тем проще их разместить в
"валидную" конфигурацию, и тем скорее найдётся правильный ответ.

Использованные библиотеки
---

- TypeScript -- для статической типизации, дополнительный слой отлова ошибок
- lodash -- для методов find, keys, equals в функциональном стиле

